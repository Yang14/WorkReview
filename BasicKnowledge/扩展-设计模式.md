##设计模式

###基本原则

* 单一权责：一个类和接口的权责尽量单一
* 里氏互换：子类可出现在父类出现的地方并且不会出现任何错误、异常
* 迪米特法则：一个类应该对自己需要耦合或调用的类知道最少（调用方应该之间给出结果，而非通过调用放一步一步的执行才得到结果）
* 依赖倒置：抽象不依赖细节，细节依赖抽象，模块间通过抽象发生关系（实现类不直接依赖）
* 接口隔离：只依赖需要的接口，接口应该尽可能小
* 开闭原则：对扩展开放，对修改关闭。软件应通过扩展实现变化，而非通过修改已有的代码


###工厂

* 组成：
	* creator：抽象创建类，抽象工厂
	* concreteCreator：由此类完成产品类的创建
	* product：抽象产品类，定义产品的共性
	* concreteProduct：具体工厂类可有多种（由他拥抱变化），继承product
* 优点
	* 降低模块耦合，只需知道对象名称就能得到实例
	* 扩展优秀：很容易增加产品类，符合开闭原则
	* 屏蔽产品类：使用者只关注和使用产品类的接口，不关心如何实现
	* 总结：
		* 解耦框架，高层代码只知道产品的抽象类，具体实现不用关心，符合迪米特法则；高层只依赖产品类的抽象符合依赖倒置原则；符合里氏互换，产品子类替换产品父类。
* 缺点
	* 是否有必要引入工厂方法替换new对象，增加产品类也会增加代码复杂性

###单例
 * 组成
	 * 使用private构造函数，确保应用程序中只有一个实例而且是自行实例化的。
 * 优点：
	 * 只有一个实例，减少内存开销
	 * 提高性能，特别是对象的产生需要很多资源时
 * 缺点：
	 * 扩展困难，没有接口
	 * 不利于测试，一些mock工具也无法替代，必须等他实现才能测试  

###观察者
 * 组成
	 * subject被观察者：管理观察者和通知他们；必须能动态添加、取消观察者。有添加、删除、通知方法
	 * observer观察者：接受到消息执行update操作，对消息做处理
	 * 对应的具体实现
 * 优点
	 * 观察和被观察者之间是抽象耦合的：双方扩展都很容易
	 * 建立触发机制：单一职责的类如何发生关系，由此可以串联起来
 * 缺点
	 * 开放和运行效率：多个观察者调试比较困难，多级触发时候效率问题
	 * 广播链的问题
###策略

* 组成
	* context封装角色：上下文角色，屏蔽高层模块对算法的直接访问，封装可能的变化
	* strategy抽象策略角色：多为接口，策略和算法族的抽象
	* 具体决策角色
	
* 优点
	* 算法自由切换
	* 扩展性好：增加策略很容易
* 缺点
	* 上层需要知道要用那个策略
###门面
* 组成
	* 门面角色：知道子系统的所有功能和责任
	* 子系统角色：子系统是一个或多个类的集合
* 优点
	* 减少依赖耦合：外部系统通过门面无需深入子系统内部即可获得需要的东西
	* 灵活性提高：子系统如何变化都不会影响到外部
	* 提高安全性：外部的访问途径都由门面给出
* 缺点
	* 不符合开闭原则：门面有问题只能修改无法扩展
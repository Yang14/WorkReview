##算法

**没时间了解算法具体实现的话，就先背下算法的原理、时间、空间复杂度。特别是快排和和堆排序。快排的优化。这些低下的文字都有写。**
###排序

---------

####快排

* 原理
	* 稳定性：不稳定 
	* 复杂度
		* 时间:平均O(nlogn)，最差O(n2)
		* 最差的情况：序列有序或基本有序时，会蜕变成冒泡排序。
		* 改变性能：
			* 随机快排：取中间“三者取中”的数或随机取与主元交换后做快排
			* 修化partition：low和high加减1时，做冒泡操作，将逆序对交换。并用两个bool值记录两个方向是否做过交换操作。如果low++过程中无交换，则不需要再对低端子表进行排序了（quickSort(A,p,q-1);不需执行）
		* 空间：O(logn)[记录主元只要O(1)，但是递归调用的栈深度为lgn,总的复杂度为O(logn)]
	* 分治法
		* 分解A[p...r]为A[p...q-1]<=A[q]<=A[q+1...r]
		* 递归调用子数组
		* 合并 

	* 快排伪代码如下：
	
代码1：


	void quickSort(A,p,r){
		if(q < r){
			q = partition(A,p,r);
			quickSort(A,p,q-1);
			quickSort(A,q+1,r);
		}		
	}

* 核心partition算法	
	* 双指针相向而行
	* 选第一个原始为主元
	* 后指针从后向前找比主元小的，移动到前面，直接赋值给A[p]
	* 前面指针从前向后找大的，移到后面，直接赋值给A[r]
	* 边界条件，两指针不能相交
	* 最后将主元赋值A[p],返回p

代码2：
	
	void int partition(A,p,r){
		key = A[p];
		while(p < r){
			while(p<r && A[r] >= key) r--;
			A[p] = A[r];
			while(p<r && A[p] <= key) p++;
			A[r] = A[p];
		}
		A[p] = key;			//**p==r，才是主元的最后位置**
		return p;
	}	


* 前后双指针
* j在i前面，找到 <=x的就与i交换
* i指针（前指针）指向的及以前的数字都 <= x;
* >=i+1的数都 >x 
* 最后将i+1与主元交换，并返回i+1
	  
代码3：

	void int partition(A,p,r){
		key = A[r];
		i = p - 1;
		for(j=p; j<=r-1; j++){
			if(A[j] <= key){
				i++;
				A[i] <-> A[j];
			}
		}
		i++;
		A[i] <-> A[r];
		return i;
	}


####归并

* 稳定性：稳定

* 时间复杂度：O(nlgn)

* 空间复杂度：O(n)，与待排序数组空间相等

* **思路**：无论是链式结构还是数组，合并两个或者多个有序列表成一个新的有序列表的时间为O(m + n)

* **归并的思想**：先将数组两两归并，形成长度为2或1的有序子序列；再两两归并，直至得到长度为n的有序序列为止

下面给出2-路归并排序算法的伪代码：（注：2-路实用性很差只作为例子）


	void mergeSort(sr,tr1,s,t){
		//将无序sr[s...t]合并为有序tr1[s...t]
		if(s == t) tr1[s] = sr[s];
		else {
			m = (s + t)/2;				//将sr均分成两份，分别对两份做归并
			mergeSort(sr,tr2,s,m);		//递归地将sr[s...t]归并为有序tr2[s...t]
			mergeSort(sr,tr2,m+1,t);	//同上
			mergeSort(tr2,tr1,s,t);		//将tr2[s...t]归并到tr1[s...t]
		}
	}

	void merge(sr,tr,i,m,n){
		//将有序的sr[i...m],sr[m+1...n]合并为tr[i...n]
		j = m + 1;
		for(k=i; i<=m && j <= n; ++k){
			if(sr[i] <= sr[j]) tr[k] = sr[i++];
			else tr[k] = sr[j++];
		}
		if(i<=m) tr[i...m] = sr[i...m];
		if(j<=n) tr[j...n] = sr[j...n];
	}

####堆排

* 稳定性：不稳定
* 时间复杂度：O(nlgn)
* 空间复杂度：O(1)，用于交换
* 
* 数据结构：将一维数组看成完全二叉树
* 堆的定义：完全二叉树中所有非终端节点的值均不大于（或小于）左右子树节点的值。[根节点大于孩子节点]

* 为了满足堆的定义并利用堆的性质做排序，需要先将无序序列建立堆，再调整输出堆顶元素后调整剩余元素成为新的堆
* 建堆是完全二叉树最后一个非终节点第n/2下取整个元素开始
	
		void buildHeap(A,n){
			for(i=n/2; i>=0 ;--i){ //从n/2开始调整到根节点
				maxHeap(A,i,n);
			}
		}


* **最大堆**调整的过程

		void maxHeap(A,i,n){
			int left = 2*i + 1;		//左孩子，i从0开始
			int right = 2*(i+1);
			int large = i;
			//找出根和左右孩子节点中最大的
			if(left < n && A[left] > A[i])  large = left;
			if(right < n && A[right] > A[large])  large = right;
			if(large != s){
				//如果根不是最大的，根需要与最大的值交换
				A[large] <-> A[s];
				//交换后可能破坏下面的堆结构，需要递归调整
				maxHeap(A,large,n);	//此时的large表示之前的根，也就是会影响其他堆的节点
			}
		}

* 最大堆排序
		
		void heapSort(A,n){
			buildHeap(A,n);     //建堆
			for(i=n-1; i>=1; i--){
				A[i] <-> A[0];	//最大的移到最后面
				maxHeap(A,0,i); //移走最大的后就需要从根开始调整了，但数量每次减少一个
			}
		}

####计数排序


* 稳定性：稳定
* 时间复杂度：O(n + k)，**比任何比较排序都快** 
* 伪代码如下：

		void countSort(A,B,k){
			//A为无序数列，B为目标有序序列，k为A中数字的范围
			for(i=0; i<A.length; ++i){
				c[A[i]]++;		//计数A中数字出现的次数
			}
			for(i=1; i<k; ++i){
				c[i] = c[i] + c[i-1];		//计算0-k个数的排名
			}
			for(i=A.length-1; i>=0; --i){	//从后向前整理，可保持稳定
				t = A[i];
				B[c[A[i]-1] = t;		//个数比下标大1，要-1
				c[t]--;				//出现多次的数字，每处理一次排名-1
			}
		}


####外部排序---多路归并排序

* 多路归并，内存中无法同时保持几个有序段和归并结果，所以外部排序不仅要merge，还要进行外存的读写

* 外部排序时间 = 内部排序（无序段变有序段）时间 + 外存读写时间 + 归并时间

* 单纯通过增大k-路归并中的k是无法减少排序时间的
	* 随k增加，归并次数减少，外存读写时间减少，但归并时间增加
	* u个记录分布在k个归并段上，归并第一个记录是k段中最小的，k个u中取第一个比较k-1次可得出结果；同理，得到含u个记录的归并段需要(u-1)(k-1)次比较
	* 两个时间的减少和增加会相互抵消会减少k增大带来的优势

* 采用败者树比较k个数中最小的只需lgk（k个叶子节点）的常量时间，减小k增大导致的归并时间。

* 胜者、败者树：
* 两种树都是完全二叉树，叶子节点为比赛选手，非终节点记录比赛结果，比赛的胜者（败者）参加更高层的比赛。
* 优点：任何叶子节点变化，都可以利用非终节点在logk的时间内找到最值。
* 区别：
	* 胜者的非终节点记录胜利者，败者记录失败者。败者树的根节点记录失败者，根节点上还有一个节点记录整场比赛的胜利者。
	* 败者树的重构过程比胜者简单，只需与非终节点（父节点比较，不需和兄弟节点比较）；胜者树需要和兄弟节点比较得出胜者。
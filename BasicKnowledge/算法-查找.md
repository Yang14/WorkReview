##算法

###查找

---------

####静态查找

* 二分查找
 
	1.二分查找的时间复杂度是O(log(n)),最坏情况下的时间复杂度是O(log(n))
	
	2.二分查找的一个条件是待查询的数组是有序的。
	
	3.二分查找的主要思路是：
	
	* n个对象从小到大存放在有序顺序表ST中，k为给定值。
	* 设low、high指向待查元素所在区间的下界、上界，即low=1,high=n
	* 设mid指向待查区间的中点，即mid=(low+high)/2û让k与mid指向的记录比较
	* 若k=ST[mid].key，查找成功，结束
	* 若k<ST[mid].key，则high=mid-1 [上半区间]
	* 若k>ST[mid].key，则low=mid+1 [下半区间]
	* 重复3,4操作，直至low>high时，查找失败。

	4.代码

		int Binary(int *r,int len,int key)
		{
		 int l,h,mid;
		 l=1;
		 h=len;
		 while(l<=h)
		 {
		  mid=(l+h)/2;
		  if(r[mid]==key)
		   return mid;
		  else if(r[mid]<key)
		            l=mid+1;
		  else
		   h=mid-1;
		 }
		 return -1;
		}


####动态查找

* 二叉排序树：每个节点都不比它左子树的任意元素小，而且不比它的右子树的任意元素大。

![二叉搜索树](./pics/二叉搜索树.png)

	二叉搜索树可以方便的实现搜索算法。在搜索元素x的时候，我们可以将x和根节点比较:

	1. 如果x等于根节点，那么找到x，停止搜索 (终止条件)
	
	2. 如果x小于根节点，那么搜索左子树
	
	3. 如果x大于根节点，那么搜索右子树
	
* 节点的删除
	
	删除节点相对比较复杂。删除节点后，有时需要进行一定的调整，以恢复二叉搜索树的性质(每个节点都不比它左子树的任意元素小，而且不比它的右子树的任意元素大)。

	* 叶节点可以直接删除。
	* 删除非叶节点时，比如下图中的节点8，我们可以删除左子树中最大的元素(或者右树中最大的元素)，用删除的节点来补充元素8产生的空缺。但该元素可能也不是叶节点，所以它所产生的空缺需要其他元素补充…… 直到最后删除一个叶节点。上述过程可以递归实现。 

![二叉树删除节点](./pics/二叉树删除节点.png)
![二叉树删除节点后](./pics/二叉树删除节点后.png)